/**
 * Script to automatically generate entity and migration index files
 * 
 * This script scans the codebase and generates:
 * - src/database/all-entities.ts (from **/*.entity.ts files)
 * - src/database/all-migrations.ts (from migrations/*.ts files)
 * 
 * Run this script before building with esbuild to ensure all entities
 * and migrations are included in the bundle.
 * 
 * Usage: node scripts/generate-indexes.js
 */

const fs = require('fs');
const path = require('path');

const API_ROOT = path.join(__dirname, '..');
const SRC_DIR = path.join(API_ROOT, 'src');
const MIGRATIONS_DIR = path.join(API_ROOT, 'migrations');
const DATABASE_DIR = path.join(SRC_DIR, 'database');

/**
 * Recursively find all files matching a pattern
 */
function findFiles(dir, pattern, files = []) {
  if (!fs.existsSync(dir)) return files;
  
  const items = fs.readdirSync(dir);
  for (const item of items) {
    const fullPath = path.join(dir, item);
    const stat = fs.statSync(fullPath);
    
    if (stat.isDirectory()) {
      // Skip node_modules and other non-essential directories
      if (item !== 'node_modules' && item !== 'dist' && item !== '.git') {
        findFiles(fullPath, pattern, files);
      }
    } else if (pattern.test(item)) {
      files.push(fullPath);
    }
  }
  
  return files;
}

/**
 * Extract class name from a TypeScript file
 * Looks for: export class ClassName
 */
function extractClassName(filePath) {
  const content = fs.readFileSync(filePath, 'utf-8');
  
  // Match: export class ClassName (possibly with extends/implements)
  const match = content.match(/export\s+class\s+(\w+)/);
  if (match) {
    return match[1];
  }
  
  return null;
}

/**
 * Generate the all-entities.ts file
 */
function generateEntitiesIndex() {
  console.log('Scanning for entity files...');
  
  const entityFiles = findFiles(SRC_DIR, /\.entity\.ts$/);
  
  if (entityFiles.length === 0) {
    console.warn('No entity files found!');
    return;
  }
  
  console.log(`Found ${entityFiles.length} entity files`);
  
  // Extract class names and relative paths
  const entities = [];
  for (const filePath of entityFiles) {
    const className = extractClassName(filePath);
    if (className) {
      // Get relative path from database/ directory
      const relativePath = path.relative(DATABASE_DIR, filePath)
        .replace(/\\/g, '/') // Convert Windows paths to Unix
        .replace(/\.ts$/, ''); // Remove .ts extension
      
      entities.push({ className, relativePath, filePath });
    } else {
      console.warn(`Could not extract class name from: ${filePath}`);
    }
  }
  
  // Sort by class name for consistency
  entities.sort((a, b) => a.className.localeCompare(b.className));
  
  // Generate the file content
  const imports = entities.map(e => 
    `import { ${e.className} } from '${e.relativePath}';`
  ).join('\n');
  
  const exports = entities.map(e => `  ${e.className},`).join('\n');
  
  const content = `/**
 * AUTO-GENERATED FILE - DO NOT EDIT MANUALLY
 * 
 * This file is automatically generated by scripts/generate-indexes.js
 * Run \`yarn generate:indexes\` to regenerate.
 * 
 * Generated: ${new Date().toISOString()}
 * Entities found: ${entities.length}
 */

${imports}

// Export all entities as an array for TypeORM configuration
export const AllEntities = [
${exports}
];
`;

  const outputPath = path.join(DATABASE_DIR, 'all-entities.ts');
  fs.writeFileSync(outputPath, content);
  console.log(`âœ… Generated ${outputPath} with ${entities.length} entities`);
}

/**
 * Generate the all-migrations.ts file
 */
function generateMigrationsIndex() {
  console.log('Scanning for migration files...');
  
  if (!fs.existsSync(MIGRATIONS_DIR)) {
    console.warn('Migrations directory not found!');
    return;
  }
  
  const files = fs.readdirSync(MIGRATIONS_DIR)
    .filter(f => f.endsWith('.ts') && !f.startsWith('.'))
    .sort(); // Sort alphabetically (which is chronological for timestamp-named files)
  
  if (files.length === 0) {
    console.warn('No migration files found!');
    return;
  }
  
  console.log(`Found ${files.length} migration files`);
  
  // Extract class names
  const migrations = [];
  for (const file of files) {
    const filePath = path.join(MIGRATIONS_DIR, file);
    const className = extractClassName(filePath);
    
    if (className) {
      const relativePath = `../../migrations/${file.replace(/\.ts$/, '')}`;
      migrations.push({ className, relativePath, file });
    } else {
      console.warn(`Could not extract class name from: ${file}`);
    }
  }
  
  // Generate the file content
  const imports = migrations.map(m => 
    `import { ${m.className} } from '${m.relativePath}';`
  ).join('\n');
  
  const exports = migrations.map(m => `  ${m.className},`).join('\n');
  
  const content = `/**
 * AUTO-GENERATED FILE - DO NOT EDIT MANUALLY
 * 
 * This file is automatically generated by scripts/generate-indexes.js
 * Run \`yarn generate:indexes\` to regenerate.
 * 
 * Generated: ${new Date().toISOString()}
 * Migrations found: ${migrations.length}
 * 
 * IMPORTANT: Migrations are listed in chronological order (by filename).
 */

${imports}

// Export all migrations as an array for TypeORM configuration
// Order matters! Migrations are run in the order they appear in this array.
export const AllMigrations = [
${exports}
];
`;

  const outputPath = path.join(DATABASE_DIR, 'all-migrations.ts');
  fs.writeFileSync(outputPath, content);
  console.log(`âœ… Generated ${outputPath} with ${migrations.length} migrations`);
}

/**
 * Main function
 */
function main() {
  console.log('ðŸ”„ Generating TypeORM index files...\n');
  
  // Ensure database directory exists
  if (!fs.existsSync(DATABASE_DIR)) {
    fs.mkdirSync(DATABASE_DIR, { recursive: true });
  }
  
  generateEntitiesIndex();
  console.log('');
  generateMigrationsIndex();
  
  console.log('\nâœ… All index files generated successfully!');
}

main();
