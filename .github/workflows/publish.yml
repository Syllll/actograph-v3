name: Build and Publish Release

on:
  push:
    tags:
      - 'prod-v*.*.*'

jobs:
  build-and-upload:
    strategy:
      matrix:
        include:
          - os: ubuntu-latest
          - os: windows-latest
          - os: macos-13 # Intel x64 runner
            electron_arch: "x64"
          - os: macos-14 # Apple Silicon arm64 runner
            electron_arch: "arm64"
    runs-on: ${{ matrix.os }}
    environment: deploy
    permissions:
      contents: write 

    steps:
      - name: Extract version from tag
        id: get_version
        run: echo "VERSION=${GITHUB_REF#refs/tags/prod-v}" >> $GITHUB_OUTPUT
        shell: bash

      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      # Windows-only steps for certificate handling
      - name: Decode certificate
        if: matrix.os == 'windows-latest'
        run: |
          echo ${{ secrets.WIN_CERT_BASE64 }} > certificate.b64
          certutil -decode certificate.b64 front/certificate.pfx
        shell: bash

      - name: Replace security functions
        shell: bash
        env:
          PKV_GET_KEY_BYTE: ${{ secrets.PKVGETKEYBYTE }}
          PKV_CHECK_KEY: ${{ secrets.PKVCHECKKEY }}
        run: |
          node -e '
            const fs = require("fs");
            const filePath = "api/src/core/security/services/key-testor.ts";
            
            let content = fs.readFileSync(filePath, "utf8");
            
            // Replace each function
            const replacements = [
              {
                pattern: /private pkvGetKeyByte\(seed: ulint, a: ulint, b: ulint, c: ulint\): ulint {[\s\S]*?^  }/m,
                replacement: `private pkvGetKeyByte(seed: ulint, a: ulint, b: ulint, c: ulint): ulint {${process.env.PKV_GET_KEY_BYTE}}`
              },
              {
                pattern: /private pkvCheckKey\(s: string, blackListedKeys: string\[\] = \[\]\): KeyStatus {[\s\S]*?^  }/m,
                replacement: `private pkvCheckKey(s: string, blackListedKeys: string[] = []): KeyStatus {${process.env.PKV_CHECK_KEY}}`
              }
            ];
            
            for (const {pattern, replacement} of replacements) {
              content = content.replace(pattern, replacement);
            }
            
            fs.writeFileSync(filePath, content);
          '

      - name: Update package.json versions
        shell: bash
        run: |
          # Update API package.json
          jq '.version = "${{ steps.get_version.outputs.VERSION }}"' api/package.json > api/package.json.tmp
          mv api/package.json.tmp api/package.json
          
          # Update Frontend package.json
          jq '.version = "${{ steps.get_version.outputs.VERSION }}"' front/package.json > front/package.json.tmp
          mv front/package.json.tmp front/package.json

      - name: Get package.json hash
        id: package-json-hash
        shell: bash
        run: |
          if [ -f front/package.json ]; then
            # Utiliser shasum sur macOS, sha256sum sur Linux
            if command -v sha256sum > /dev/null 2>&1; then
              HASH=$(cat front/package.json | sha256sum | cut -d' ' -f1)
            elif command -v shasum > /dev/null 2>&1; then
              HASH=$(cat front/package.json | shasum -a 256 | cut -d' ' -f1)
            else
              # Fallback: utiliser openssl si disponible
              HASH=$(cat front/package.json | openssl dgst -sha256 | cut -d' ' -f2)
            fi
            echo "hash=$HASH" >> $GITHUB_OUTPUT
          else
            echo "hash=no-package-json" >> $GITHUB_OUTPUT
          fi

      - name: Create API .env file
        shell: bash
        run: |
          echo "# Container exposed ports on the host
          BACKEND_DOCKER_APP_PORT_EXPOSED=3044
          BACKEND_DOCKER_PSQL_PORT_EXPOSED=5644

          # BACK and FRONT URLS (ex. https://mydomain.com or http://localhost:3236)
          API_URL=http://localhost:3044
          FRONTEND_URL=http://localhost:8044

          # Name of the app, used in e-mails and in the frontend
          APP_NAME=actograph-v3-api

          # LOCAL DB
          DB_TYPE=sqlite #postgres
          DB_HOST=localhost #actograph-v3-api-dev-db
          DB_PORT=5432
          DB_USERNAME=${{ vars.DB_USERNAME }}
          DB_PASSWORD=${{ secrets.DB_PASSWORD }}
          DB_NAME=actograph.sqlite # actograph db

          # Generate a strong (40 chars) random password using tools like https://www.dashlane.com/personal-password-manager/password-generator
          JWT_SECRET=s0me-10ng-and-rAnd0m-str1ng-here-t00

          # This will create the first admin user upon first start
          ADMINUSER_LOGIN=${{ vars.ADMINUSER_LOGIN }}
          ADMINUSER_PASSWORD=${{ secrets.ADMINUSER_PASSWORD }}

          # API
          ACTOGRAPH_API=${{ vars.ACTOGRAPH_API }}
          ACTOGRAPH_API_PASSWORD=${{ secrets.ACTOGRAPH_API_PASSWORD }}" > api/.env

      - name: Create Frontend .env file
        shell: bash
        run: |
          echo "FRONT_DOCKER_PORT_EXPOSED=8044
          API_URL=http://localhost:3044
          APP_NAME=actograph-v3
          # Modes = dark|light
          DEFAULT_COLOR_MODE=light
          AMCHART5_LICENCE_KEY=${{ secrets.AMCHART5_LICENCE_KEY }}" > front/.env

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'

      - name: Install Python dependencies
        run: |
          python -m pip install --upgrade pip
          pip install setuptools wheel

      - name: Setup Yarn
        run: npm install -g yarn

      # Cache yarn dependencies
      - name: Get yarn cache directory path
        id: yarn-cache-dir-path
        shell: bash
        run: echo "dir=$(yarn cache dir)" >> $GITHUB_OUTPUT

      - name: Get yarn.lock hash
        id: yarn-lock-hash
        shell: bash
        run: |
          if [ -f api/yarn.lock ] && [ -f front/yarn.lock ]; then
            # Utiliser shasum sur macOS, sha256sum sur Linux
            if command -v sha256sum > /dev/null 2>&1; then
              HASH=$(cat api/yarn.lock front/yarn.lock | sha256sum | cut -d' ' -f1)
            elif command -v shasum > /dev/null 2>&1; then
              HASH=$(cat api/yarn.lock front/yarn.lock | shasum -a 256 | cut -d' ' -f1)
            else
              # Fallback: utiliser openssl si disponible
              HASH=$(cat api/yarn.lock front/yarn.lock | openssl dgst -sha256 | cut -d' ' -f2)
            fi
            echo "hash=$HASH" >> $GITHUB_OUTPUT
          else
            echo "hash=no-lockfiles" >> $GITHUB_OUTPUT
          fi

      - name: Cache yarn dependencies
        uses: actions/cache@v4
        with:
          path: |
            front/node_modules
            api/node_modules
            ${{ steps.yarn-cache-dir-path.outputs.dir }}
          # Isolate cache by OS and architecture (important for macOS x64 vs arm64)
          key: ${{ runner.os }}-${{ matrix.electron_arch || 'default' }}-yarn-${{ steps.yarn-lock-hash.outputs.hash }}
          restore-keys: |
            ${{ runner.os }}-${{ matrix.electron_arch || 'default' }}-yarn-
            ${{ runner.os }}-yarn-

      # Cache Electron binaries
      - name: Cache Electron
        uses: actions/cache@v4
        with:
          path: |
            ~/.cache/electron
            ~/.cache/electron-builder
          key: ${{ runner.os }}-electron-${{ matrix.electron_arch || 'default' }}-${{ steps.package-json-hash.outputs.hash }}
          restore-keys: |
            ${{ runner.os }}-electron-${{ matrix.electron_arch || 'default' }}-
            ${{ runner.os }}-electron-

      - name: Prepare architecture flags
        id: arch_flags
        run: |
          if [ -n "${{ matrix.electron_arch }}" ]; then
            echo "flags=--${{ matrix.electron_arch }}" >> $GITHUB_OUTPUT
          else
            echo "flags=" >> $GITHUB_OUTPUT
          fi
        shell: bash

      - name: Run deploy script
        run: bash scripts/build-electron.sh
        shell: bash
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          WIN_CERT_PWD: ${{ secrets.WIN_CERT_PWD }}
          # Use ELECTRON_BUILDER_ARCH for architecture-specific builds (macOS only)
          ELECTRON_BUILDER_ARCH: ${{ matrix.electron_arch || '' }}
          # Keep ELECTRON_ARCH_FLAGS for backward compatibility with build script
          ELECTRON_ARCH_FLAGS: ${{ steps.arch_flags.outputs.flags }}
          # Set Electron cache directory
          ELECTRON_CACHE: ~/.cache/electron
          # Skip Electron binary download during yarn install - electron-builder will handle it
          ELECTRON_SKIP_BINARY_DOWNLOAD: 1
          # AmCharts license key for build-time
          AMCHART5_LICENCE_KEY: ${{ secrets.AMCHART5_LICENCE_KEY }}

      # Clean up certificate for Windows only
      - name: Clean up certificate
        if: matrix.os == 'windows-latest' && always()
        run: |
          if exist certificate.pfx del /q certificate.pfx
          if exist certificate.b64 del /q certificate.b64
        shell: cmd

      # Instead of uploading to release here, let's save artifacts
      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: electron-artifacts-${{ matrix.os }}
          path: |
            front/dist/electron/Packaged/*.exe
            front/dist/electron/Packaged/*.dmg
            front/dist/electron/Packaged/*.AppImage
            front/dist/electron/Packaged/*.snap
            front/dist/electron/Packaged/latest*.yml
            front/dist/electron/Packaged/latest*.yaml
            front/dist/electron/Packaged/*-mac.zip
            front/dist/electron/Packaged/*.blockmap

  create-release:
    needs: build-and-upload
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          # Fetch tags to enable git describe
          fetch-depth: 0

      - name: Extract version from tag
        id: get_version
        run: |
          # Get the latest tag that matches prod-v*.*.* pattern
          VERSION=$(git describe --tags --match 'prod-v*.*.*' --abbrev=0 | sed 's/prod-v//')
          echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
          echo "Extracted version: $VERSION"
        shell: bash

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: Normalize mac update files to avoid duplicate names
        run: |
          set -e
          # Enable nullglob to handle cases where no files match
          shopt -s nullglob
          # Find and rename latest-mac.yml files for macOS builds
          # Handle macos-14 (arm64)
          if [ -d "artifacts/electron-artifacts-macos-14" ]; then
            if [ -f "artifacts/electron-artifacts-macos-14/latest-mac.yml" ]; then
              mv artifacts/electron-artifacts-macos-14/latest-mac.yml artifacts/electron-artifacts-macos-14/latest-mac-arm64.yml
            fi
            # Also handle any other YAML files that might be generated
            for file in artifacts/electron-artifacts-macos-14/latest-mac*.yml artifacts/electron-artifacts-macos-14/latest-mac*.yaml; do
              if [ -f "$file" ] && [[ ! "$file" =~ (arm64|x64) ]]; then
                mv "$file" "${file%.*}-arm64.yml"
              fi
            done
          fi
          # Handle macos-13 (x64)
          if [ -d "artifacts/electron-artifacts-macos-13" ]; then
            if [ -f "artifacts/electron-artifacts-macos-13/latest-mac.yml" ]; then
              mv artifacts/electron-artifacts-macos-13/latest-mac.yml artifacts/electron-artifacts-macos-13/latest-mac-x64.yml
            fi
            # Also handle any other YAML files that might be generated
            for file in artifacts/electron-artifacts-macos-13/latest-mac*.yml artifacts/electron-artifacts-macos-13/latest-mac*.yaml; do
              if [ -f "$file" ] && [[ ! "$file" =~ (arm64|x64) ]]; then
                mv "$file" "${file%.*}-x64.yml"
              fi
            done
          fi
        shell: bash

      - name: Prepare release bundle (dedupe artifacts)
        run: |
          set -e
          mkdir -p artifacts/release
          # macOS x64 from macos-13
          if compgen -G "artifacts/electron-artifacts-macos-13/ActoGraph-v3-x64.dmg" > /dev/null; then
            cp -f artifacts/electron-artifacts-macos-13/ActoGraph-v3-x64.dmg artifacts/release/
          fi
          if compgen -G "artifacts/electron-artifacts-macos-13/ActoGraph-v3-x64.dmg.blockmap" > /dev/null; then
            cp -f artifacts/electron-artifacts-macos-13/ActoGraph-v3-x64.dmg.blockmap artifacts/release/
          fi
          # Include macOS x64 ZIP files if they exist (Electron Builder may generate ZIP files)
          if compgen -G "artifacts/electron-artifacts-macos-13/*mac*.zip" > /dev/null; then
            # Copy ZIP files, renaming if needed to include architecture
            for zipfile in artifacts/electron-artifacts-macos-13/*mac*.zip; do
              if [[ "$zipfile" =~ x64 ]] || [[ ! "$zipfile" =~ (arm64|x64) ]]; then
                cp -f "$zipfile" artifacts/release/
              fi
            done
          fi
          if compgen -G "artifacts/electron-artifacts-macos-13/latest-mac-x64.yml" > /dev/null; then
            cp -f artifacts/electron-artifacts-macos-13/latest-mac-x64.yml artifacts/release/
          fi
          # macOS arm64 from macos-14
          if compgen -G "artifacts/electron-artifacts-macos-14/ActoGraph-v3-arm64.dmg" > /dev/null; then
            cp -f artifacts/electron-artifacts-macos-14/ActoGraph-v3-arm64.dmg artifacts/release/
          fi
          if compgen -G "artifacts/electron-artifacts-macos-14/ActoGraph-v3-arm64.dmg.blockmap" > /dev/null; then
            cp -f artifacts/electron-artifacts-macos-14/ActoGraph-v3-arm64.dmg.blockmap artifacts/release/
          fi
          # Include macOS arm64 ZIP files if they exist (Electron Builder may generate ZIP files)
          if compgen -G "artifacts/electron-artifacts-macos-14/*mac*.zip" > /dev/null; then
            # Copy ZIP files, renaming if needed to include architecture
            for zipfile in artifacts/electron-artifacts-macos-14/*mac*.zip; do
              if [[ "$zipfile" =~ arm64 ]] || [[ ! "$zipfile" =~ (arm64|x64) ]]; then
                cp -f "$zipfile" artifacts/release/
              fi
            done
          fi
          if compgen -G "artifacts/electron-artifacts-macos-14/latest-mac-arm64.yml" > /dev/null; then
            cp -f artifacts/electron-artifacts-macos-14/latest-mac-arm64.yml artifacts/release/
          fi
          # Linux
          if compgen -G "artifacts/electron-artifacts-ubuntu-latest/*.AppImage" > /dev/null; then
            cp -f artifacts/electron-artifacts-ubuntu-latest/*.AppImage artifacts/release/
          fi
          if compgen -G "artifacts/electron-artifacts-ubuntu-latest/latest-linux.yml" > /dev/null; then
            cp -f artifacts/electron-artifacts-ubuntu-latest/latest-linux.yml artifacts/release/
          fi
          # Windows
          if compgen -G "artifacts/electron-artifacts-windows-latest/*.exe" > /dev/null; then
            cp -f artifacts/electron-artifacts-windows-latest/*.exe artifacts/release/
          fi
          if compgen -G "artifacts/electron-artifacts-windows-latest/*.exe.blockmap" > /dev/null; then
            cp -f artifacts/electron-artifacts-windows-latest/*.exe.blockmap artifacts/release/
          fi
          if compgen -G "artifacts/electron-artifacts-windows-latest/latest.yml" > /dev/null; then
            cp -f artifacts/electron-artifacts-windows-latest/latest.yml artifacts/release/
          fi

      - name: Setup Node.js (for YAML merge)
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install js-yaml in release folder
        run: |
          set -e
          mkdir -p artifacts/release
          cd artifacts/release
          npm init -y >/dev/null 2>&1 || true
          npm install js-yaml

      - name: Merge mac update YAML into latest-mac.yml
        run: |
          set -e
          cd artifacts/release
          if [ -f latest-mac-x64.yml ] && [ -f latest-mac-arm64.yml ]; then
            echo "Merging mac YAMLs into latest-mac.yml"
            node -e '
              const fs = require("fs");
              const yaml = require("js-yaml");
              const x64 = yaml.load(fs.readFileSync("latest-mac-x64.yml", "utf8"));
              const arm = yaml.load(fs.readFileSync("latest-mac-arm64.yml", "utf8"));
              const merged = { ...x64 };
              merged.files = [...(x64.files || []), ...(arm.files || [])];
              fs.writeFileSync("latest-mac.yml", yaml.dump(merged));
            '
          elif [ -f latest-mac-x64.yml ]; then
            cp latest-mac-x64.yml latest-mac.yml
          elif [ -f latest-mac-arm64.yml ]; then
            cp latest-mac-arm64.yml latest-mac.yml
          fi
        shell: bash

      - name: Create Release
        uses: softprops/action-gh-release@v1
        with:
          name: actograph-v3 v${{ steps.get_version.outputs.VERSION }}
          # Use consistent tag naming: keep prod-v prefix to match trigger
          tag_name: prod-v${{ steps.get_version.outputs.VERSION }}
          files: artifacts/release/*
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
